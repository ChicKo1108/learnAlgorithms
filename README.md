# learnAlgorithms
> 学习JavaScript数据结构与算法



## 动态规划（Dynamic Programming）

当遇到**求最优解问题**，一般可以想到使用动态规划问题（Dynamic Programming）来解决。
动态规划有三个重要的概念：

1. 最优子结构
2. 边界
3. 状态转移方程

-------------

### [面试题 17.16. 按摩师](https://leetcode-cn.com/problems/the-masseuse-lcci/)

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 

示例 1：

```
输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
```

示例 2：

```
输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
```

示例 3：

```
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。
```

-------------------

分析一下本题的三要素

#### 最优子结构

由于无法接受相邻的预约，所以第i个预约的状态取决于第i-1个预约是否接受：

- 第i个预约接受，则第i-1个预约无法接受
- 第i个预约不接受，则第i-1个预约是否接受都可以

所以关键点在于**“是否接受”**这个状态，构建一个二维数组来表示是否接受：

- `dp[i][0]` 其中第一个索引i表示在预约数组中的第i个预约，第二个索引0则表示不接受第i个预约
- `dp[i][1]`第二个索引1表示接受第i个预约

#### 边界

动态规划的核心就是“大事化小，小事化了”。即问题可以分解为若干个子问题，这种形式十分适合用“自底向上”的视角来解决。

既然是自底向上，那么就必须梳理出初始状态，即边界。

第`i`个预约的状态值和第`i-1`个预约的状态值相关，第`i-1`个预约的状态值由与第`(i-1)-1`个预约相关。以此类推，第2个预约就只和第1个预约相关。

所以可以得出边界值，第1个预约的状态：

- `dp[0][0] = 0`：第一个预约不接受，所以总时长等于0
- `dp[0][1] = num[0]`：第一个预约接受，所以总时长等于第一个的值

#### 状态转移方程

状态转移方程是解决动态规划问题的核心突破点，一旦方程成立，问题就迎刃而解。

可以将状态转移方程简单理解为“梳理不同阶段的联系“。

之前分析得出，第i个预约接受与否，取决于第i-1个的状态。则预约时长就有两种状态：

- `dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1])`：如果第`i`个预约请求不接受，则它的总预约时长就应当取「第`i-1`个预约**接受**总时长」和「第`i-1`预约**不接受**总时长」之中的最大值。
- `dp[i][1] = dp[i-1][0] + nums[i]` ：如果第`i`个预约请求接受，则它的总预约时长就直接是「第`i-1`个预约不接受的总时长」加上「第`i`个预约接受的时长」。

#### 代码实现

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var massage = function (nums) {
  if (nums.length == 0) return 0;
  const dp = [];
  // 创建二维数组
  for (let i = 0; i < nums.length; i++) {
    dp[i] = [0, 0];
  }
  // 边界条件
  dp[0][0] = 0;
  dp[0][1] = nums[0];
  for (let i = 1; i < nums.length; i++) {
    // 状态转移方程
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
    dp[i][1] = dp[i - 1][0] + nums[i];
  }
  return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
};

console.log(massage([2, 1, 4, 5, 3, 1, 1, 3])); // 12
```

